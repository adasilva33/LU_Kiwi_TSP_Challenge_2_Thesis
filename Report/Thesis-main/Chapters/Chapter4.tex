\chapter{Methodology}
\label{Chapter4}
\lhead{Chapter 4. \emph{Methodology}}
%\todo{Describe implementation details}
\newpage

\tikzset{class/.style={rectangle, draw=green!60, fill=green!5, very thick, minimum size=20},
    method/.style={rectangle, draw=yellow!60, fill=yellow!5, very thick, minimum size=20},
    attributes/.style={rectangle, draw=blue!60, fill=blue!5, very thick, minimum size=20},
    instance/.style={rectangle, draw=orange!60, fill=orange!5, very thick, minimum size=20}
}


\section{Monte Carlo Tree Search implementation}
\subsection{General flow}

Based on the discussion in Chapter \ref{Chapter2}, the flow of the Monte Carlo Tree Search algorithm is summarised in Figure \ref{fig:Flow MCTS}:
\begin{figure}[!ht]
    \centering
    \begin{tikzpicture}[
            startstop/.style={ellipse, minimum width=3cm, minimum height=1cm, text centered, draw=black},
            process/.style={rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black},
            decision/.style={rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, decorate, decoration={zigzag,segment length=2,amplitude=1}},
            arrow/.style={thick,->,>=stealth},
            node distance=2cm
        ]

        \node (start) [startstop] {start};
        \node (current) [process, below of=start] {Node = $S_0$};
        \node (decision1) [decision, below of=current, yshift=-0.5cm] {is Node a leaf node?};
        \node (ucb1) [process, below of=decision1, yshift=-1cm, align=center] {Node = child node of Node \\ that minimises the \\ chosen selection function};
        \node (decision2) [decision, right of=decision1, xshift=4cm] {Has Node been visited};
        \node (expand) [process, below of=decision2, yshift=-1cm, align=center] {For each available action\\ from Node, add a new \\ state to the tree};
        \node (firstChild) [process, below of=expand] {Node = random new child node};
        \node (rollout1) [process, below of=firstChild] {ROLLOUT - simulation policy};
        \node (rollout2) [process, above of=decision2] {ROLLOUT - simulation policy};

        \draw [arrow] (start) -- (current);
        \draw [arrow] (current) -- (decision1);
        \draw [arrow] (decision1) -- node[anchor=east] {no} (ucb1);
        \draw [arrow] (ucb1) -- (decision1);
        \draw [arrow] (decision1) -- node[anchor=south] {yes} (decision2);
        \draw [arrow] (decision2) -- node[anchor=east] {yes} (expand);
        \draw [arrow] (decision2) -- node[anchor=east] {no} (rollout2);
        \draw [arrow] (expand) -- (firstChild);
        \draw [arrow] (ucb1.west) -- ++(-1,0) |- (decision1.west);
        \draw [arrow] (firstChild) -- (rollout1);

    \end{tikzpicture}
    \caption{Flow MCTS}
    \label{fig:Flow MCTS}
\end{figure}

For every iteration of this algorithm, there are four different phases:

\begin{enumerate}
    \item \textbf{Selection:} Starting from the root node (the starting airport $S_{i0}$ for $I_{i}$), select successive child nodes (airports that are in unvisited areas) until a leaf node (the airport in the initial area, not necessarly the starting airport) is reached. Use the chosen Selection function to evaluate which node is the most promising. In the illustrative example in Section \ref{subsub:Example}, the UCB1 function was used for the selection function. Furthermore, the problem's goal was to maximise the objective function, hence the nodes with the highest UCB1 value was selected. A contrario, in Kiwi's minimisation problem,  nodes are evaluated based on the lowest value of the selection function.

    \item \textbf{Expansion:} If the selected node is not a terminal node, expand the tree by adding all possible child nodes.

    \item \textbf{Simulation:} From the newly added node, perform a simulation (based on the simulation policy) until a feasible terminal node is reached.

    \item \textbf{Backpropagation:} Update the values of the nodes along the path from the newly added node to the root based on the result of the simulation.

          \begin{equation}
              \mathcal{B}(S^{n_i,t_i}_i) = S^{n_i+1,t_i+\mathcal{R}(S^{n_i,t_i}_i)}_i
          \end{equation}

          where $\mathcal{R}(S^{n_i,t_i}_i)$ is the cost of the solution found after performing a simulation from node $S^{n_i,t_i}_i$.
\end{enumerate}


\newpage
\subsubsection{Data Preprocessing}

To implement our MCTS' solution, the first thing to create is a data\_preprocessing \tikz[baseline=(class.base)]{\node[class] (class) {class};} to prepare the given instance to the problem at hand.
Kiwi's challenge is solved using Python 3.10 on VS Code 1.92.2. Our Python code is structured using object-oriented programming following CamelCase's convention \cite{camel_case}. This data\_preprocessing class is represented on Figure \ref{fig:data_preprocessing_class}.
The input is an \tikz[baseline=(instance.base)]{\node[instance] (instance) {instance};} $I_i$, as defined in Chapter \ref{Chapter3}:

\begin{figure}[!ht]
    \centering
    \begin{tikzpicture}[
            class/.style={rectangle, draw=green!60, fill=green!5, very thick, minimum size=40},
            methods/.style={rectangle, draw=yellow!60, fill=yellow!5, very thick, minimum size=40},
            attributes/.style={rectangle, draw=blue!60, fill=blue!5, very thick, minimum size=40},
            instance/.style={rectangle, draw=orange!60, fill=orange!5, very thick, minimum size=40}
        ]

        %Nodes  
        \node[instance]          (Instance){$I_i = (N_i, S_{i0}, A_{i}, F_{i})$};
        \node[class]             (Class)[below=of Instance]{DataPreprocessing};

        \node[attributes, left=of  Class , yshift=-40] (Attr1) {$N_i$};
        \node[attributes, left=of  Class , yshift=-90] (Attr2) {$S_{i0}$};
        \node[attributes, left=of  Class , yshift=-140] (Attr3) {flights\_by\_day\_dict};
        \node[attributes, left=of  Class, yshift=-190] (Attr4) {airports\_by\_area};
        \node[attributes, left=of  Class, yshift=-240] (Attr5) {area\_by\_airport};
        %\node[methods, left=of Class, yshift=-290, align=center] (Meth10) {flights\_from\_airport\_at\_a\_\\specific\_day\_with\_previous\_areas};
        \node[methods, left=of Class, yshift=-290, align=center] (Meth10) {specific\_flights};


        \node[methods, right=of  Class, yshift=-40] (Meth1) {read\_file};
        \node[methods, right=of  Class, yshift=-90] (Meth2) {flights\_by\_day};
        \node[methods, right=of  Class, yshift=-140] (Meth3) {flights\_from\_airport};
        \node[methods, right=of  Class, yshift=-190] (Meth4) {associated\_area\_to\_airport};
        \node[methods, right=of  Class, yshift=-240] (Meth5) {get\_cost};
        \node[methods, right=of  Class, yshift=-290] (Meth6) {get\_airports\_by\_areas};
        \node[methods, below=of  Class, yshift=-220] (Meth7) {remove\_duplicate};

        %Lines
        \draw[->, very thick] (Instance.south)  to node[midway, right] {} (Class.north);

        \draw[->] (Class.south) to[out=180, in=0] (Attr1.east);
        \draw[->] (Class.south) to[out=190, in=0] (Attr2.east);
        \draw[->] (Class.south) to[out=200, in=0] (Attr3.east);
        \draw[->] (Class.south) to[out=210, in=0] (Attr4.east);
        \draw[->] (Class.south) to[out=220, in=0] (Attr5.east);

        % Arrows from Class to Methods (right side)
        \draw[->] (Class.south) to[out=0, in=180] (Meth1.west);
        \draw[->] (Class.south) to[out=350, in=180] (Meth2.west);
        \draw[->] (Class.south) to[out=340, in=180] (Meth3.west);
        \draw[->] (Class.south) to[out=330, in=180] (Meth4.west);
        \draw[->] (Class.south) to[out=320, in=180] (Meth5.west);

        \draw[->] (Class.south) to[out=-115, in=30] (Meth10.east);
        \draw[->] (Class.south) to[out=-65, in=150] (Meth6.west);
        \draw[->] (Class.south) to[out=-90, in=90] (Meth7.north);
    \end{tikzpicture}
    \caption{Explanation of the data preprocessing class}
    \label{fig:data_preprocessing_class}
\end{figure}

Different useful \tikz[baseline=(methods.base)]{\node[method] (methods) {methods};} are implemented within the data\_preprocessing class to compute and manage various attributes required for the problem at hand. These methods are designed to prepare and structure the data, making it easier to use in subsequent phases of the algorithm.
For example, the remove\_duplicate method ensures that only the cheapest flight connections are considered between two airports if multiple flight connections exist at different prices, on the same day.
Other methods, such as flights\_by\_day\_dict and get\_airports\_by\_areas organise the data. The first method regroups all the flights by their respective days, creating a dictionary where each key represents a day and its corresponding value is a list of available flights. The second method regroups all the airports present in the different areas.

Finally, other methods, such as specific\_flights, will be useful for developing the MCTS' algorithm. These give all the possible flight connections from a specific airport on a given day, taking into account the areas visited, so that all possible actions can be obtained from a node.


Given that Python is relatively slower, in terms of computation, compared to other programming languages, dictionnaries are used where possible. Dictionnaries allow for efficient data retrieval based on a key, with an average time complexity of $\mathcal{O}(1)$. This choice improves the performance of the data preprocessing step, enabling the algorithm to run more efficiently despite Python’s inherent limitations.

\newpage
\subsubsection{Node}
\label{subsub:node}
\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
            class/.style={rectangle, draw=green!60, fill=green!5, very thick, minimum size=40},
            methods/.style={rectangle, draw=yellow!60, fill=yellow!5, very thick, minimum size=40},
            attributes/.style={rectangle, draw=blue!60, fill=blue!5, very thick, minimum size=40},
            instance/.style={rectangle, draw=orange!60, fill=orange!5, very thick, minimum size=40}
        ]

        \node[class]             (Class){\phantom{-----}Node\phantom{-----}};

        \node[attributes, left=of  Class , yshift=-40] (Attr1) {state};
        \node[attributes, left=of  Class , yshift=-90] (Attr2) {parent};
        \node[attributes, left=of  Class , yshift=-140] (Attr3) {children};
        \node[attributes, left=of  Class, yshift=-190] (Attr4) {visit\_count};

        \node[methods, right=of  Class, yshift=-40] (Meth1) {add\_child};
        \node[methods, right=of  Class, yshift=-90] (Meth2) {delete\_node};
        \node[methods, right=of  Class, yshift=-140] (Meth3) {best\_child};
        \node[methods, right=of  Class, yshift=-190] (Meth4) {update};

        \node[attributes, below=of  Class, yshift=-120] (Meth5) {total\_cost};


        \draw[->] (Class.south) to[out=180, in=0] (Attr1.east);
        \draw[->] (Class.south) to[out=190, in=0] (Attr2.east);
        \draw[->] (Class.south) to[out=200, in=0] (Attr3.east);
        \draw[->] (Class.south) to[out=210, in=0] (Attr4.east);

        \draw[->] (Class.south) to[out=0, in=180] (Meth1.west);
        \draw[->] (Class.south) to[out=350, in=180] (Meth2.west);
        \draw[->] (Class.south) to[out=340, in=180] (Meth3.west);
        \draw[->] (Class.south) to[out=330, in=180] (Meth4.west);

        \draw[->] (Class.south) to[out=-90, in=90] (Meth5.north);

    \end{tikzpicture}
    \caption{Explanation of the Node class}
    \label{fig:node_class}
\end{figure}

As mentionned earlier in Section \ref{subsub:Example}, a Node structure is used in the algorithm, hence the implementation of a Node class.
Each Node has a reference to a parent node (unless it is the root node) and may have one or more child nodes (unless it is a leaf node). These relationships form a tree structure where each node can expand into potential future states, guiding the search process.
The visit\_count tracks the number of times a node has been visited during the MCTS process. This is crucial for evaluating the node’s importance and for calculating the score of the node with the selection function.
The state is a dictionnary that contains the node's current information:
\begin{itemize}
    \item current\_airport: The airport where the traveler is  at this node.
    \item current\_day: The day of the trip at this node.
    \item remaining\_zones: The zones that still need to be visited to complete the journey.
    \item visited\_zones: The zones that have already been visited to ensure that all zones are visited exactly once during the trip.
    \item total\_cost: It represents the accumulated cost of the current solution path leading to this node.
\end{itemize}

Additionally, to manage the expansion of child nodes, the add\_child method is defined.
This method generates new nodes based on the possible actions available from the current node. These new nodes represent the next possible states in the traveler’s journey, allowing the search tree to expand and explore different travel routes.
Finally, the delete\_node method can be used to delete a node from the list of its parent's children.


\section{The different policies}
In the previous section, we outlined the general flow of the MCTS algorithm, focusing on two cores classes, DataPreprocessing and Node, that are central in MCTS' implementation.

In Section \ref{sub:selection_policies_litterature}, we explored the various selection policies that guide the decision-making process within the MCTS
Although there is a limited litterature review, we decided to parameterise not only the selection policy but also the simulation and expansion policies.

\subsection{Simulation policies}
\label{sub:simulation_policies}
When a simulation is runned from a given node in the tree, the goal is to find a feasible combinaison of airports that could be a solution to our problem.
From this node chosen for simulation, we obtain the current state (defined in section \ref{subsub:node}). The remaining actions must then be chosen to find a simulated solution based on the simulation policy.

Below is the definition of the three distinct simulation policies:

\begin{itemize}
    \item Random policy: This policy selects a random action from the set of available actions, introducing variability and exploration in the simulation process.
    \item Greedy policy: This policy selects the action that corresponds to the cheapest available flight connection, thus prioritising cost minimisation at each step.

    \item Tolerance policy (with coefficient $c$):
          This policy selects an action randomly from a subset of actions that are within a certain tolerance level of the minimum cost action. The tolerance level is defined by a coefficient $c$. The tolerance policy is defined as follows:
          \begin{itemize}
              \item Identify the cheapest flight connection among the available actions $c_{min}$.
              \item Filter the actions to include only those with a cost less or equal than $c_{min}(1+c) $.
              \item Randomly select an action from this filtered set.
          \end{itemize}

\end{itemize}



\subsection{Expansion policies}
\label{sub:expansion_policies}
When expanding a node, it’s theoretically possible to expand all available child nodes i.e.\ add to the tree all the possible flight connections from this airport (that are in the available actions based on the visited areas). However, in practice, this can be computationally expensive and time-consuming, particularly in problems with a large number of possible actions. To address this, heuristic approaches often involve compromises that enhance the efficiency of the search process by selectively expanding certain nodes rather than all possible ones.

Firstly, we defined \texttt{number\_of\_children}, a parameter of our MCTS algorithm which regulates the maximum number of children that can be expanded from any given node. This limitation controls the size of the search tree, as expanding too many children for every selected node could make the algorithm computationally exhaustive.

In our implementation we defined two expansion policies:

\begin{itemize}
    \item \textbf{Top-K Actions Policy}: This policy expands the nodes corresponding to the cheapest flight connections available. Specifically, it sorts all possible actions based on their associated costs and selects the top \(k\) actions with the lowest costs, where \(k\) is regulated by \texttt{number\_of\_children}. This approach ensures that only the most promising actions, in terms of cost efficiency, are considered during expansion. This policy narrows down the search space but can increase the chance to reach a leaf node.
    \item \textbf{Ratio Best-Random Policy}: This policy takes a more balanced approach by combining the selection of the best actions with a degree of randomness. First, it calculates the number of top actions to select based on a predefined ratio, \(c \in [0,1]\), which reflects the proportion of Top-K Actions within the allowed \texttt{number\_of\_children}. After selecting these best actions, the policy randomly selects $(1-c)*number\_of\_children$ actions from the remaining pool to reach the desired number of children. This policy is designed to explore a broader range of possibilities while still prioritising cost-effective options.
\end{itemize}

\subsection{Notations}
\label{sub:notations}

After definining the different parameters of the MCTS, a MCTS function can be defined as follow:

\begin{center}
    \centering
    $\begin{array}{ccccc}
            \mathcal{MCTS} & : & S_p(C_p), E_p(c), R_p, N_c & \mapsto & \mathcal{MCTS}(S_p(C_p), E_p(c), R_p, N_c) \\
        \end{array}$
\end{center}

where:
\begin{itemize}
    \item $S_p(C_p)$: Selection policy (UCB or UCB1-T) with exploration parameter $C_p$ (defined in Section \ref{sub:selection_policies_litterature}).
    \item $E_p(c)$: Expansion policy (Top-K ratio or best random) with proportion $c$ (defined in Section \ref{sub:expansion_policies}).
    \item $R_p$: Rollout/simulation policy (random, tolerance, or greedy) (defined in Section \ref{sub:simulation_policies}).
    \item $N_c$: Maximum number of children added during node expansion.
\end{itemize}

\subsection{Pseudo-code}
In this section, the implementation of the algorithm in practice is explored by examining the different functions of our MCTS class. The search function of the MCTS is defined:

\begin{algorithm}[H]
    \caption{Search\_Function}
    \label{alg:MCTS}
    \begin{algorithmic}[1]
        \STATE Initialise Root\_Node with Initial\_State
        \WHILE{Tree is not fully explored}
        \STATE $Node \leftarrow \text{Select}(Root\_Node)$
        \IF{$Node$ is not fully expanded}
        \STATE $Node \leftarrow \text{Expand}(Node)$
        \ENDIF
        \STATE $Cost \leftarrow \text{Simulate}(Node)$
        \STATE \text{Backpropagate}($Node$, $Cost$)
        \ENDWHILE
        \RETURN $Best\_Leaf\_Node$
    \end{algorithmic}
\end{algorithm}
The \texttt{Search} function represents the general flow of the algorithm as mentionned on Figure \ref{fig:Flow MCTS}.

The \texttt{Select} function (Algorithm \ref{alg:SelectFunction}), which selects the node to visit, returns two arguments: a boolean and a node. The boolean indicates to the expansion function whether expansion is necessary (True means no expansion needed, False means expansion needed).

\begin{algorithm}[H]
    \caption{Select\_Function}
    \label{alg:SelectFunction}
    \begin{algorithmic}[1]
        \STATE \textbf{Input:} $Node$
        \STATE $Current \leftarrow Node$
        \WHILE{$Current.Children$ is not empty}
        \IF{Current is not fully expanded}
        \STATE $UnvisitedChildren \leftarrow \text{Children with } VisitCount = 0$
        \IF{$UnvisitedChildren$ is not empty}
        \STATE $SelectedChild \leftarrow \text{Randomly select from } UnvisitedChildren$
        \RETURN $True, SelectedChild$
        \ENDIF
        \ELSE
        \STATE $Current \leftarrow \text{BestChild}(Current)$
        \ENDIF
        \ENDWHILE
        \IF{$Current.Children$ is empty \textbf{and} $Current.State["current\_day"]==N_{Areas}$}
        \RETURN $False, Current$
        \ELSIF{$Current.Children$ is empty \textbf{and} $Current.State["current\_day"]<>N_{Areas}$}
        \RETURN $False, Current$
        \ELSIF{$Current.State["current\_day"]==N_{Areas} + 1$}
        \RETURN $True, Current$
        \ENDIF
    \end{algorithmic}
\end{algorithm}

There are special cases to handle, when one approaches the final solution because one has to communicate the right information to the \texttt{Expand Node} function.

After simulating, the backpropagation function updates the node's attributes. The new node becomes the parent of this node, and so on until \texttt{Node} is \texttt{None}, i.e., all the information is backpropagated up to the root node.

\begin{algorithm}[H]
    \caption{Backpropagate\_Function}
    \label{alg:Backpropagate}
    \begin{algorithmic}[1]
        \WHILE{$Node$ is not $None$}
        \STATE $Node.Update(Cost)$
        \STATE $Node \leftarrow Node.Parent$
        \ENDWHILE
    \end{algorithmic}
\end{algorithm}

The transition function modifies the states of a node by updating the current airport, the visited zones, remaining zones, etc.

\begin{algorithm}[H]
    \caption{Transition\_Function}
    \label{alg:TransitionFunction}
    \begin{algorithmic}[1]
        \STATE $New\_State \leftarrow \text{Copy of } State$
        \STATE $New\_State.Current\_Day \leftarrow State.Current\_Day + 1$
        \STATE $New\_State.Current\_Airport \leftarrow Action[0]$
        \STATE $New\_State.Total\_Cost \leftarrow State.Total\_Cost + Action[1]$
        \STATE \text{Update}($New\_State.Path$, $New\_State.Current\_Airport$)
        \STATE \text{Remove\_Visited}($New\_State.Remaining\_Zones$, $New\_State.Current\_Airport$)
        \STATE \text{Add\_Visited}($New\_State.Visited\_Zones$, $New\_State.Current\_Airport$)
        \RETURN $New\_State$
    \end{algorithmic}
\end{algorithm}

Finally, the Best Child function, defined in the Node class is based on the selection function UCB and UCB1\_Tuned. They both, compute the score of the visited nodes and pick the one that minimises the selection function.

\begin{algorithm}[H]
    \caption{Best Child}
    \label{alg:Best Child}
    \begin{algorithmic}[1]
        \REQUIRE $Selection\_Function$
        \STATE $Visited\_Children \leftarrow \text{Children with } visitCount > 0$
        \STATE $Choices\_Weights \leftarrow \left[ Selection\_Function(child) \text{ for child in } Visited\_Children \right]$
        \STATE $Best\_Child\_Node \leftarrow \text{Child with minimum } Choices\_Weights$
        \RETURN $Best\_Child\_Node$
    \end{algorithmic}
\end{algorithm}
